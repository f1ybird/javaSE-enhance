【接口】

1.接口中的所有方法自动地属于public。

2.对任意的x和y，需保证sgn(x.compareTo(y)) = -sgn(y.compareTo(x))。

3.接口中不能包含实例域和静态方法，但可以包含常量。

4.接口中的域将自动被设为public static final。

【内部类】

内部类的意义？

1.完善多重继承。

C++作为比较早期的面向对象编程语言，摸着石头过河，不幸的当了炮灰。比如多重继承，Java是不太欢迎继承的。因为继承耦合度太高。比如你是一个人，你想会飞，于是就继承了鸟这个类，然后你顺便拥有了一对翅膀和厚厚的羽毛，可这些玩意你并不需要。所以Java发明了接口，以契约的方式向你提供功能。想想看，你的程序里成员变量会比函数多吗？况且多重继承会遇到死亡菱形问题，就是两个父类有同样名字的函数，你继承谁的呢？其实C++也可以做到这些，那就是定义没有成员变量的纯虚类，而且所有函数都是纯虚函数。可是这些都是要靠程序员自己把握，并没有把这些功能集成到类似Interface这样的语法里。所以Java只支持单重继承，想扩展功能，去实现接口吧。很快Java的设计者就发现了他们犯了矫枉过正的错误，多重继承还是有一定用处的。比如每一个人都是同时继承父亲和母亲两个类，要不然你的身体里怎么能留着父母的血呢？Java内部类应运而生。


2.实现事件驱动系统。

用来开发GUI的Java Swing使用了大量内部类，主要用来响应各种事件。Swing的工作就是在事件就绪的时候执行事件，至于事件具体怎么做，这由事件决定。这里面有两个问题：

1.事件必须要用到继承
2.事件必须能访问到Swing。所以必须把事件写成内部类。

3.闭包。

内部类是面向对象的闭包，因为它不仅包含创建内部类的作用域的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。一般使用一个库或类时，是你主动调用人家的API，这个叫Call，有的时候这样不能满足需要，需要你注册（注入）你自己的程序（比如一个对象)，然后让人家在合适的时候来调用你，这叫Callback。当父类和实现的接口出现同名函数时，你又不想父类的函数被覆盖，回调可以帮你解决这个问题。

注：闭包就是能够读取其他函数内部变量的函数。由于在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
=============

1.内部类可以对同一个包中的其他类隐藏起来。

2.内部类是否有用，必要和安全。

编译器会把内部类翻译成用$分割外部类名和内部类名的常规类文件，而虚拟机对此一无所知。 
javap是jdk自带的一个工具，可以反编译，也可以查看java编译器生成的字节码，可以使用javap -private ClassName查看类的信息。（UINX下要使用\$对$符转义）。

3.内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。所以内部类的成员变量/方法名可以和外部类的相同。

====================
内部类的特点总结
====================

(1)  在方法间定义的非静态内部类： 
        外围类和内部类可互相访问自己的私有成员。
        内部类中不能定义静态成员变量。

(2) 在方法间定义的静态内部类：
        只能访问外部类的静态成员。
 
(3) 在方法中定义的局部内部类：【闭包】
        该内部类没有任何的访问控制权限
        外围类看不见方法中的局部内部类的，但是局部内部类可以访问外围类的任何成员。
        方法体中可以访问局部内部类，但是访问语句必须在定义局部内部类之后。
        局部内部类只能访问方法体中的常量，即用final修饰的成员。

(4) 在方法中定义的匿名内部类：
        没有构造器，取而代之的是将构造器参数传递给超类构造器。